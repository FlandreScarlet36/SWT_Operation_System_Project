<h1><center>lab2实验报告</center></h1>

## 练习一

算法的主要思想是维护一个空闲块列表，当有内存请求时，从列表中找到第一个足够大的块来满足请求。

**物理内存分配过程**：从空闲内存块的链表上查找第一个大小大于所需内存的块，分配出去，回收时会按照地址从小到大的顺序插入链表，并且合并与之相邻且连续的空闲内存块。

**各个函数的作用**：

+ `default_init`：初始化空闲内存块的链表，将空闲块的个数设置为0。
  + 初始化了空闲块列表 `free_list` 以及空闲页面数量 `nr_free`。

+ `default_init_memmap`：用于初始化一个空闲内存块。他会查询空闲内存块的链表，按照地址顺序插入到合适的位置，并将空闲内存块个数加n。
  + 首先初始化了每个页面的属性，包括标志位 `flags` 和 `property`，并将页面引用计数设置为0。
  + 然后，它将首个页面的 `property` 设置为块的总数，表示此块中的页面数量。
  + 最后，它将这些页面添加到 `free_list` 中，并更新 `nr_free` 计数。

+ `default_alloc_pages`：用于分配给定大小的内存块。如果剩余空闲内存块大小多于所需的内存区块大小，则从链表中查找大小超过所需大小的页，并更新该页剩余的大小。
  + 遍历空闲块列表，查找第一个满足请求的块（块大小大于等于 `n`）。
  + 如果找到了合适的块，会将块分割成两部分，一部分用于分配，另一部分保留在列表中。
  + 如果分割后剩余的块大小大于 `n`，则更新剩余块的 `property` 并将其添加到列表中。
  + 最后，它减少 `nr_free` 计数，并标记已分配的页面。

+ `default_free_pages`：用于释放内存块。将释放的内存块按照顺序插入到空闲内存块的链表中，并合并与之相邻且连续的空闲内存块。
  + 首先将页面的属性重置，并将页面引用计数设置为0。
  + 然后，将页面添加到空闲块列表中，同时尝试合并相邻的空闲块。
  + 如果释放的页面与前一个页面或后一个页面相邻，会尝试将它们合并为一个更大的空闲块。
  + 最后，更新 `nr_free` 计数。


**改进空间：**

* 更高效的内存块合并策略
* 更快速的空闲块搜索算法
* 支持内存回收策略
* 更灵活的内存分配策略

## 练习二

**设计实现过程**：在分配内存块时，按照顺序查找，遇到第一块比所需内存块大的空闲内存块时，先将该块分配给`page`，之后继续查询，如果查询到大小比分配的内存块小的空闲内存块，将`page`更新为当前的内存块。释放内存块时，按照顺序将其插入链表中，并合并与之相邻且连续的空闲内存块。

核心步骤的实现如下：

```c
while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n && p->property < min_size) {
            page = p;
            min_size = p->property;
        }
    }
```

## 扩展练习：可用物理内存获取

* 可以分段检测物理内存是否被占用，获得未被占用的物理内存。
* 向内存中写入并读取数据，如果超过内存范围，那么不管写入什么，再读取都会返回零。
* 利用BIOS的终端功能：BIOS终端会提供一个检索内存的功能，会返回一个结构体到指定位置。

## 重点内容

* 多级页表管理
* 课程中仅涉及二级页表，但实验中设计使用了三级页表，需要额外学习
* 缺页等异常处理操作